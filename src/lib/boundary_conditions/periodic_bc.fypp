! MIT License
! Copyright (c) 2019 Sam Miller
! Permission is hereby granted, free of charge, to any person obtaining a copy
! of this software and associated documentation files (the "Software"), to deal
! in the Software without restriction, including without limitation the rights
! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
! copies of the Software, and to permit persons to whom the Software is
! furnished to do so, subject to the following conditions:
!
! The above copyright notice and this permission notice shall be included in all
! copies or substantial portions of the Software.
!
! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
! SOFTWARE.

module mod_periodic_bc

  use, intrinsic :: iso_fortran_env, only: ik => int32, rk => real64
  use mod_functional, only: reverse, operator(.reverse.)
  use mod_field, only: field_2d_t
  use mod_globals, only: enable_debug_print, debug_print
  use mod_grid, only: grid_t
  use mod_boundary_conditions, only: boundary_condition_t
  use mod_input, only: input_t

  implicit none

  private
  public :: periodic_bc_t, periodic_bc_constructor

  type, extends(boundary_condition_t) :: periodic_bc_t
    logical :: do_corners = .false.
  contains
    procedure, public :: apply => apply_periodic_primitive_var_bc
    final :: finalize
  end type periodic_bc_t

contains

  function periodic_bc_constructor(location, input, grid) result(bc)
    type(periodic_bc_t), pointer :: bc
    character(len=2), intent(in) :: location !< Location (+x, -x, +y, or -y)
    class(input_t), intent(in) :: input
    class(grid_t), intent(in) :: grid

    allocate(bc)
    bc%name = 'periodic'
    bc%location = location
    call bc%set_indices(grid)

    if(trim(input%plus_x_bc) == 'periodic' .and. &
       trim(input%minus_x_bc) == 'periodic' .and. &
       trim(input%plus_y_bc) == 'periodic' .and. &
       trim(input%minus_y_bc) == 'periodic') then

      bc%do_corners = .true.
    end if

  end function periodic_bc_constructor

  subroutine apply_periodic_primitive_var_bc(self, rho, u, v, p)

    class(periodic_bc_t), intent(inout) :: self
    class(field_2d_t), intent(inout) :: rho
    class(field_2d_t), intent(inout) :: u
    class(field_2d_t), intent(inout) :: v
    class(field_2d_t), intent(inout) :: p

    integer(ik) :: i, j
    integer(ik) :: donor_istart, donor_iend, receiver_istart, receiver_iend
    integer(ik) :: donor_j, receiver_j

    associate(left => self%ilo, right => self%ihi, bottom => self%jlo, top => self%jhi, &
              left_ghost => self%ilo_ghost, right_ghost => self%ihi_ghost, &
              bottom_ghost => self%jlo_ghost, top_ghost => self%jhi_ghost)

      select case(self%location)
      case('+x')
        call debug_print('Running periodic_bc_t%apply_periodic_primitive_var_bc() +x', __FILE__, __LINE__)

        do i = 1, self%n_ghost_layers
          #:for f in ['rho','u','v','p']
          ${f}$%data(right_ghost(i), bottom:top) = ${f}$%data(left + (i - 1), bottom:top)
          #:endfor
        end do

        if(self%do_corners) then
          ! Values for the donor and reciever indices
          donor_istart = left
          donor_iend = left + self%n_ghost_layers - 1
          receiver_istart = right_ghost(1)
          receiver_iend = receiver_istart + self%n_ghost_layers - 1

          ! Do this one j "chunk" at a time. It grabs all of the i indices, e.g. ilo:ihi and
          ! assigns them one j layer at a time
          do j = 1, self%n_ghost_layers
            donor_j = bottom + (j - 1)
            receiver_j = top_ghost(j)

            #:for f in ['rho','u','v','p']
            ${f}$%data(receiver_istart:receiver_iend, receiver_j) = ${f}$%data(donor_istart:donor_iend, donor_j)
            #:endfor

            donor_j = top - (j - 1)
            receiver_j = bottom_ghost(j)

            #:for f in ['rho','u','v','p']
            ${f}$%data(receiver_istart:receiver_iend, receiver_j) = ${f}$%data(donor_istart:donor_iend, donor_j)
            #:endfor
          end do
        end if

      case('-x')
        call debug_print('Running periodic_bc_t%apply_periodic_primitive_var_bc() -x', __FILE__, __LINE__)

        do i = 1, self%n_ghost_layers
            #:for f in ['rho','u','v','p']
          ${f}$%data(left_ghost(i), bottom:top) = ${f}$%data(right - (i - 1), bottom:top)
            #:endfor
        end do

        if(self%do_corners) then
          ! Values for the donor and reciever indices
          donor_istart = right - self%n_ghost_layers + 1
          donor_iend = right
          receiver_istart = left_ghost(1) - self%n_ghost_layers + 1
          receiver_iend = left_ghost(1)

          ! Do this one j "chunk" at a time. It grabs all of the i indices, e.g. ilo:ihi and
          ! assigns them one j layer at a time
          do j = 1, self%n_ghost_layers
            donor_j = bottom + (j - 1)
            receiver_j = top_ghost(j)

              #:for f in ['rho','u','v','p']
            ${f}$%data(receiver_istart:receiver_iend, receiver_j) = ${f}$%data(donor_istart:donor_iend, donor_j)
              #:endfor

            donor_j = top - (j - 1)
            receiver_j = bottom_ghost(j)

              #:for f in ['rho','u','v','p']
            ${f}$%data(receiver_istart:receiver_iend, receiver_j) = ${f}$%data(donor_istart:donor_iend, donor_j)
              #:endfor
          end do
        end if

      case('+y')
        call debug_print('Running periodic_bc_t%apply_periodic_primitive_var_bc() +y', __FILE__, __LINE__)

        do i = 1, self%n_ghost_layers
          #:for f in ['rho','u','v','p']
            ${f}$%data(left:right, top_ghost(i)) = ${f}$%data(left:right, bottom + (i - 1))
          #:endfor
        end do

        if(self%do_corners) then
          ! Values for the donor and reciever indices
          donor_istart = left
          donor_iend = left + self%n_ghost_layers - 1
          receiver_istart = right_ghost(1)
          receiver_iend = receiver_istart + self%n_ghost_layers - 1

          ! Do this one j "chunk" at a time. It grabs all of the i indices, e.g. ilo:ihi and
          ! assigns them one j layer at a time
          do j = 1, self%n_ghost_layers
            donor_j = bottom + (j - 1)
            receiver_j = top_ghost(j)

                #:for f in ['rho','u','v','p']
            ${f}$%data(receiver_istart:receiver_iend, receiver_j) = ${f}$%data(donor_istart:donor_iend, donor_j)
                #:endfor

            donor_j = top - (j - 1)
            receiver_j = bottom_ghost(j)

                #:for f in ['rho','u','v','p']
            ${f}$%data(receiver_istart:receiver_iend, receiver_j) = ${f}$%data(donor_istart:donor_iend, donor_j)
                #:endfor
          end do
        end if

      case('-y')
        call debug_print('Running periodic_bc_t%apply_periodic_primitive_var_bc() -y', __FILE__, __LINE__)

        do i = 1, self%n_ghost_layers
          #:for f in ['rho','u','v','p']
            ${f}$%data(left:right, bottom_ghost(i)) = ${f}$%data(left:right, top - (i - 1))
          #:endfor
        end do

        if(self%do_corners) then
          ! Values for the donor and reciever indices
          donor_istart = right - self%n_ghost_layers + 1
          donor_iend = right
          receiver_istart = left_ghost(1) - self%n_ghost_layers + 1
          receiver_iend = left_ghost(1)

          ! Do this one j "chunk" at a time. It grabs all of the i indices, e.g. ilo:ihi and
          ! assigns them one j layer at a time
          do j = 1, self%n_ghost_layers
            donor_j = bottom + (j - 1)
            receiver_j = top_ghost(j)

                #:for f in ['rho','u','v','p']
            ${f}$%data(receiver_istart:receiver_iend, receiver_j) = ${f}$%data(donor_istart:donor_iend, donor_j)
                #:endfor

            donor_j = top - (j - 1)
            receiver_j = bottom_ghost(j)

                #:for f in ['rho','u','v','p']
            ${f}$%data(receiver_istart:receiver_iend, receiver_j) = ${f}$%data(donor_istart:donor_iend, donor_j)
                #:endfor
          end do
        end if

      case default
        error stop "Unsupported location to apply the bc at in periodic_bc_t%apply_periodic_cell_gradient_bc()"
      end select
    end associate

  end subroutine apply_periodic_primitive_var_bc

  subroutine finalize(self)
    type(periodic_bc_t), intent(inout) :: self
    call debug_print('Running periodic_bc_t%finalize()', __FILE__, __LINE__)
    if(allocated(self%ilo_ghost)) deallocate(self%ilo_ghost)
    if(allocated(self%ihi_ghost)) deallocate(self%ihi_ghost)
    if(allocated(self%jlo_ghost)) deallocate(self%jlo_ghost)
    if(allocated(self%jhi_ghost)) deallocate(self%jhi_ghost)
  end subroutine

end module mod_periodic_bc
