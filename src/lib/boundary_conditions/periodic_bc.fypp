! MIT License
! Copyright (c) 2019 Sam Miller
! Permission is hereby granted, free of charge, to any person obtaining a copy
! of this software and associated documentation files (the "Software"), to deal
! in the Software without restriction, including without limitation the rights
! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
! copies of the Software, and to permit persons to whom the Software is
! furnished to do so, subject to the following conditions:
!
! The above copyright notice and this permission notice shall be included in all
! copies or substantial portions of the Software.
!
! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
! SOFTWARE.

module mod_periodic_bc

  use, intrinsic :: iso_fortran_env, only: ik => int32, rk => real64, std_err => error_unit
  use mod_error, only: error_msg
  use mod_functional, only: reverse, operator(.reverse.)
  use mod_field, only: field_2d_t
  use mod_globals, only: enable_debug_print, debug_print
  use mod_grid_block_2d, only: grid_block_2d_t
  use mod_boundary_conditions, only: boundary_condition_t
  use mod_parallel, only: LOWER_LEFT, DOWN, LOWER_RIGHT, LEFT, &
                          RIGHT, UPPER_LEFT, UP, UPPER_RIGHT
  use mod_input, only: input_t
  use mod_functional, only: set

  implicit none

  private
  public :: periodic_bc_t, periodic_bc_constructor

  type, extends(boundary_condition_t) :: periodic_bc_t
    logical :: do_corners = .false.
  contains
    procedure, public :: apply => apply_periodic_primitive_var_bc
    final :: finalize
  end type periodic_bc_t

contains

  function periodic_bc_constructor(location, input, grid) result(bc)
    type(periodic_bc_t), pointer :: bc
    character(len=2), intent(in) :: location !< Location (+x, -x, +y, or -y)
    class(input_t), intent(in) :: input
    class(grid_block_2d_t), intent(in) :: grid

    allocate(bc)
    bc%name = 'periodic'
    bc%location = location
    call bc%set_indices(grid)

    if(trim(input%plus_x_bc) == 'periodic' .and. &
       trim(input%minus_x_bc) == 'periodic' .and. &
       trim(input%plus_y_bc) == 'periodic' .and. &
       trim(input%minus_y_bc) == 'periodic') then

      bc%do_corners = .true.
    end if

  end function periodic_bc_constructor

  subroutine apply_periodic_primitive_var_bc(self, rho, u, v, p)

    class(periodic_bc_t), intent(inout) :: self
    class(field_2d_t), intent(inout) :: rho
    class(field_2d_t), intent(inout) :: u
    class(field_2d_t), intent(inout) :: v
    class(field_2d_t), intent(inout) :: p

    integer(ik) :: i, j
    integer(ik) :: donor_istart, donor_iend, receiver_istart, receiver_iend
    integer(ik) :: donor_j, receiver_j

    integer(ik) :: sync_stat           !< syncronization status
    character(len=200) :: sync_err_msg !< syncronization error message (if any)
    integer(ik), dimension(8) :: neighbors = 0 !< parallel neighbor image indices

    real(rk), dimension(:, :), allocatable, save :: left_edge[:]   !< (i, j)[image]; Coarray buffer to copy left neighbor halo data
    real(rk), dimension(:, :), allocatable, save :: right_edge[:]  !< (i, j)[image]; Coarray buffer to copy right neighbor halo data
    real(rk), dimension(:, :), allocatable, save :: top_edge[:]    !< (i, j)[image]; Coarray buffer to copy top neighbor halo data
    real(rk), dimension(:, :), allocatable, save :: bottom_edge[:] !< (i, j)[image]; Coarray buffer to copy bottom neighbor halo data

    real(rk), dimension(:, :), allocatable, save :: upper_left_corner[:]  !< (i, j)[image]; Coarray buffer to copy bottom neighbor halo data
    real(rk), dimension(:, :), allocatable, save :: upper_right_corner[:] !< (i, j)[image]; Coarray buffer to copy bottom neighbor halo data
    real(rk), dimension(:, :), allocatable, save :: lower_left_corner[:]  !< (i, j)[image]; Coarray buffer to copy bottom neighbor halo data
    real(rk), dimension(:, :), allocatable, save :: lower_right_corner[:] !< (i, j)[image]; Coarray buffer to copy bottom neighbor halo data

    if(enable_debug_print) call debug_print('Running periodic_bc_t%apply_periodic_primitive_var_bc() ', __FILE__, __LINE__)
    sync_stat = 0
    sync_err_msg = ''

    ! Only allocate once, b/c this will cause an implicit sync all due to the coarray index
    associate(ni => rho%domain_shape(1), nj => rho%domain_shape(2), n_halo => rho%n_halo_cells)
      if(.not. allocated(left_edge)) allocate(left_edge(n_halo, nj)[*])
      if(.not. allocated(right_edge)) allocate(right_edge(n_halo, nj)[*])
      if(.not. allocated(top_edge)) allocate(top_edge(ni, n_halo)[*])
      if(.not. allocated(bottom_edge)) allocate(bottom_edge(ni, n_halo)[*])

      if(.not. allocated(upper_left_corner)) allocate(upper_left_corner(n_halo, n_halo)[*])
      if(.not. allocated(lower_left_corner)) allocate(lower_left_corner(n_halo, n_halo)[*])
      if(.not. allocated(upper_right_corner)) allocate(upper_right_corner(n_halo, n_halo)[*])
      if(.not. allocated(lower_right_corner)) allocate(lower_right_corner(n_halo, n_halo)[*])
    end associate

    neighbors = set(rho%neighbors)
    upper_left_corner = 0.0_rk
    upper_right_corner = 0.0_rk
    lower_left_corner = 0.0_rk
    lower_right_corner = 0.0_rk
    left_edge = 0.0_rk
    right_edge = 0.0_rk
    top_edge = 0.0_rk
    bottom_edge = 0.0_rk

    associate(ilo => rho%lbounds(1), ihi => rho%ubounds(1), &
              jlo => rho%lbounds(2), jhi => rho%ubounds(2), &
              ilo_halo => rho%lbounds_halo(1), ihi_halo => rho%ubounds_halo(1), &
              jlo_halo => rho%lbounds_halo(2), jhi_halo => rho%ubounds_halo(2), &
              nh => rho%n_halo_cells, &
              neighbors => rho%neighbors)

      select case(self%location)
      case('+x', '-x')
        if(rho%on_ilo_bc .or. rho%on_ihi_bc) then
          sync images(set([rho%host_image_id, neighbors(LEFT), neighbors(RIGHT)]), stat=sync_stat, errmsg=sync_err_msg)
          if(sync_stat /= 0) then
            call error_msg(module_name='mod_periodic_bc', class_name='periodic_bc_t', &
                          procedure_name='apply_periodic_primitive_var_bc', &
                          message="Error: unable to sync images, sync_err_msg: '"//trim(sync_err_msg)//"'", &
                          file_name=__FILE__, line_number=__LINE__)
          end if
          
          ! Put to the coarray buffer
          left_edge(:, :)[neighbors(RIGHT)] = rho%data(ihi - nh + 1:ihi, jlo:jhi)
          right_edge(:, :)[neighbors(LEFT)] = rho%data(ilo:ilo + nh - 1, jlo:jhi)

          sync images(set([rho%host_image_id, neighbors(LEFT), neighbors(RIGHT)]), stat=sync_stat, errmsg=sync_err_msg)
          if(sync_stat /= 0) then
            call error_msg(module_name='mod_periodic_bc', class_name='periodic_bc_t', &
                          procedure_name='apply_periodic_primitive_var_bc', &
                          message="Error: unable to sync images, sync_err_msg: '"//trim(sync_err_msg)//"'", &
                          file_name=__FILE__, line_number=__LINE__)
          end if

          ! Get from the coarray buffer
          if (rho%on_ihi_bc) rho%data(ihi + 1:ihi_halo, jlo:jhi) = right_edge
          if (rho%on_ilo_bc) rho%data(ilo_halo:ilo - 1, jlo:jhi) = left_edge
        endif ! on ilo or ihi bc
        
      case('+y', '-y')
        if(rho%on_jlo_bc .or. rho%on_jhi_bc) then
          sync images([rho%host_image_id, neighbors(DOWN), neighbors(UP)], stat=sync_stat, errmsg=sync_err_msg)
          if(sync_stat /= 0) then
            call error_msg(module_name='mod_periodic_bc', class_name='periodic_bc_t', &
                           procedure_name='apply_periodic_primitive_var_bc', &
                           message="Error: unable to sync images, sync_err_msg: '"//trim(sync_err_msg)//"'", &
                           file_name=__FILE__, line_number=__LINE__)
          end if

          ! Put to the coarray buffer
          bottom_edge(:, :)[neighbors(UP)] = rho%data(ilo:ihi, jhi - nh + 1:jhi)
          top_edge(:, :)[neighbors(DOWN)] = rho%data(ilo:ihi, jlo:jlo + nh - 1)

          sync images([rho%host_image_id, neighbors(DOWN), neighbors(UP)], stat=sync_stat, errmsg=sync_err_msg)
          if(sync_stat /= 0) then
            call error_msg(module_name='mod_periodic_bc', class_name='periodic_bc_t', &
                          procedure_name='apply_periodic_primitive_var_bc', &
                          message="Error: unable to sync images, sync_err_msg: '"//trim(sync_err_msg)//"'", &
                          file_name=__FILE__, line_number=__LINE__)
          end if

          ! Get from the coarray buffer
          if (rho%on_jlo_bc) rho%data(ilo:ihi, jlo_halo:jlo - 1) = bottom_edge
          if (rho%on_jhi_bc) rho%data(ilo:ihi, jhi + 1:jhi_halo) = top_edge
        endif ! on jlo or jhi bc


      !   ! Get from the coarray buffer
      !   if(rho%on_jlo_bc) then
      !     sync images([rho%host_image_id, neighbors(DOWN)], stat=sync_stat, errmsg=sync_err_msg)
      !     if(sync_stat /= 0) then
      !       call error_msg(module_name='mod_periodic_bc', class_name='periodic_bc_t', &
      !                      procedure_name='apply_periodic_primitive_var_bc', &
      !                      message="Error: unable to sync images, sync_err_msg: '"//trim(sync_err_msg)//"'", &
      !                      file_name=__FILE__, line_number=__LINE__)
      !     end if

      !     rho%data(ilo:ihi, jlo_halo:jlo - 1) = top_edge    ! get the top edge from neighbor below
      !   end if

      !   if(rho%on_jhi_bc) then
      !     sync images([rho%host_image_id, neighbors(UP)], stat=sync_stat, errmsg=sync_err_msg)
      !     if(sync_stat /= 0) then
      !       call error_msg(module_name='mod_periodic_bc', class_name='periodic_bc_t', &
      !                      procedure_name='apply_periodic_primitive_var_bc', &
      !                      message="Error: unable to sync images, sync_err_msg: '"//trim(sync_err_msg)//"'", &
      !                      file_name=__FILE__, line_number=__LINE__)
      !     end if

      !     rho%data(ilo:ihi, jhi + 1:jhi_halo) = bottom_edge ! get the bottom edge from neighbor above
      !   end if
      end select
    end associate

    !   if(self%do_corners) then
      
    !   end if


    !   ! Copy data into the coarray buffer.
    !   ! We are transfering the cells from inside the real domain onto 
    !   ! the halo cells of the neighbor domain. Since
    !   ! the # of halo cells >= 1, we need to account for variable sizes.

    !   ! Send the current image's edge cells to become the halo of the neighbor
    !   right_edge(:, :)[neighbors(LEFT)] = rho%data(ilo:ilo + nh - 1, jlo:jhi) ! send to left
    !   left_edge(:, :)[neighbors(RIGHT)] = rho%data(ihi - nh + 1:ihi, jlo:jhi) ! send to right
    !   top_edge(:, :)[neighbors(DOWN)] = rho%data(ilo:ihi, jlo:jlo + nh - 1)   ! send to below
    !   bottom_edge(:, :)[neighbors(UP)] = rho%data(ilo:ihi, jhi - nh + 1:jhi)  ! send to above

    !   upper_left_corner(:, :)[neighbors(LOWER_RIGHT)] = rho%data(ihi - nh + 1:ihi, jlo:jlo + nh - 1) ! send lower-right corner
    !   lower_left_corner(:, :)[neighbors(UPPER_RIGHT)] = rho%data(ihi - nh + 1:ihi, jhi - nh + 1:jhi) ! send upper-right corner
    !   upper_right_corner(:, :)[neighbors(LOWER_LEFT)] = rho%data(ilo:ilo + nh - 1, jlo:jlo + nh - 1) ! send lower-left corner
    !   lower_right_corner(:, :)[neighbors(UPPER_LEFT)] = rho%data(ilo:ilo + nh - 1, jhi - nh + 1:jhi) ! send upper-left corner

    !   sync images(set(rho%neighbors), stat=sync_stat, errmsg=sync_err_msg)
    !   if(sync_stat /= 0) then
    !   write(std_err, '(a, i0, a)') "Error: unable to sync images in "//__FILE__//":", &
    !     __LINE__, " sync_err_msg: '"//trim(sync_err_msg)//"'"
    !   error stop "Unable to sync images, see standard error unit for more information"
    !   endif

    !   ! Now copy the edge data to the halo cells of the current image
    !   if(.not. rho%on_ilo_bc) rho%data(ilo_halo:ilo - 1, jlo:jhi) = right_edge  ! get the right edge from left neigbor
    !   if(.not. rho%on_ihi_bc) rho%data(ihi + 1:ihi_halo, jlo:jhi) = left_edge   ! get the left edge from right neigbor
    !   if(.not. rho%on_jlo_bc) rho%data(ilo:ihi, jlo_halo:jlo - 1) = top_edge    ! get the top edge from neighbor below
    !   if(.not. rho%on_jhi_bc) rho%data(ilo:ihi, jhi + 1:jhi_halo) = bottom_edge ! get the bottom edge from neighbor above

    !   if(.not. rho%on_ihi_bc .and. .not. rho%on_jhi_bc) rho%data(ihi + 1:ihi_halo, jhi + 1:jhi_halo) = lower_left_corner ! get the lower-left corner from upper-right neighbor
    !   if(.not. rho%on_ilo_bc .and. .not. rho%on_jhi_bc) rho%data(ilo_halo:ilo - 1, jhi + 1:jhi_halo) = lower_right_corner ! get the lower-right corner from upper-left neighbor
    !   if(.not. rho%on_ihi_bc .and. .not. rho%on_jlo_bc) rho%data(ihi + 1:ihi_halo, jlo_halo:jlo - 1) = upper_left_corner ! get the upper-left corner from lower-right neighbor
    !   if(.not. rho%on_ilo_bc .and. .not. rho%on_jlo_bc) rho%data(ilo_halo:ilo - 1, jlo_halo:jlo - 1) = upper_right_corner ! get the upper-right corner from lower-left neighbor
    ! end associate

  end subroutine apply_periodic_primitive_var_bc

  subroutine finalize(self)
    type(periodic_bc_t), intent(inout) :: self
    call debug_print('Running periodic_bc_t%finalize()', __FILE__, __LINE__)
    if(allocated(self%ilo_ghost)) deallocate(self%ilo_ghost)
    if(allocated(self%ihi_ghost)) deallocate(self%ihi_ghost)
    if(allocated(self%jlo_ghost)) deallocate(self%jlo_ghost)
    if(allocated(self%jhi_ghost)) deallocate(self%jhi_ghost)
  end subroutine

end module mod_periodic_bc
