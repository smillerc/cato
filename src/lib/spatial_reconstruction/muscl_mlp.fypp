! MIT License
! Copyright (c) 2020 Sam Miller
! Permission is hereby granted, free of charge, to any person obtaining a copy
! of this software and associated documentation files (the "Software"), to deal
! in the Software without restriction, including without limitation the rights
! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
! copies of the Software, and to permit persons to whom the Software is
! furnished to do so, subject to the following conditions:
!
! The above copyright notice and this permission notice shall be included in all
! copies or substantial portions of the Software.
!
! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
! SOFTWARE.

! Fypp variables. This allows us to generate an edge flux subroutine for each direction
! and still allow the compiler to optimize
#:set DIRECTIONS = ['i', 'j']
#:set SPATIAL_ORDER = [3, 5]

#ifdef __SIMD_ALIGN_OMP__
#define __INTERP_ALIGN__ aligned(q, edge_values:__ALIGNBYTES__)
#else
#define __INTERP_ALIGN__
#endif

module mod_muscl_mlp
  !> Summary: Provide TVD 2nd order MUSCL edge interpolation
  !> Date: 08/03/2020
  !> Author: Sam Miller
  !> Notes:
  !> References:
  !      [1]

  use, intrinsic :: iso_fortran_env, only: ik => int32, rk => real64, std_err => error_unit
  use mod_muscl_interpolation, only: muscl_interpolation_t
  use mod_globals, only: n_ghost_layers, debug_print, enable_debug_print
  use mod_error, only: error_msg

  implicit none
  private
  public :: muscl_mlp_t, new_muscl_mlp

  type, extends(muscl_interpolation_t) :: muscl_mlp_t
    integer(ik), dimension(:,:), allocatable :: continuity_sensor !< (i,j); flag for continuous and linear/non-linear discontinuity regions
  contains
    procedure, public :: initialize => init_muscl_mlp
    procedure, public :: interpolate_edge_values
    procedure, public :: distinguish_continuous_regions

    #:for DIR in DIRECTIONS
    #:for ORDER in SPATIAL_ORDER
    procedure, private :: interp_muscl_mlp_${DIR}$_edge_${ORDER}$_order
    #:endfor
    #:endfor

    final :: finalize
  end type

contains

function new_muscl_mlp(limiter) result(interpolator)
  type(muscl_mlp_t), pointer :: interpolator
  character(len=*), intent(in) :: limiter

  allocate(interpolator)
  interpolator%limiter_name = trim(limiter)
  interpolator%order = 2
end function

subroutine init_muscl_mlp(self, limiter)
  class(muscl_mlp_t), intent(inout) :: self
  character(len=*), intent(in) :: limiter
  self%limiter_name = trim(limiter)
  self%order = 2
end subroutine init_muscl_mlp

subroutine interpolate_edge_values(self, q, lbounds, i_edges, j_edges)
  class(muscl_mlp_t), intent(in) :: self
  integer(ik), dimension(2), intent(in) :: lbounds

  real(rk), dimension(lbounds(1):, lbounds(2):), contiguous, intent(in) :: q
  !< (i,j); primitive variable to reconstruct at the edge

  real(rk), dimension(:, :, :), allocatable, intent(out) :: i_edges
  real(rk), dimension(:, :, :), allocatable, intent(out) :: j_edges

  ! #:for DIR in DIRECTIONS
  ! call self%interp_muscl_mlp_${DIR}$_edge(q, lbounds, ${DIR}$_edges)
  ! #:endfor

end subroutine interpolate_edge_values

subroutine distinguish_continuous_regions(self, rho, u, v, p, lbounds)
  !< For plain-jane TVD2, there is no need to distinguish the regions which are continuous or linear/non-linear discontinuity regions. This
  !< is required by the parent class, but is really only implemented in the e-MLP classes.
  class(muscl_mlp_t), intent(inout) :: self
  integer(ik), dimension(2), intent(in) :: lbounds
  real(rk), dimension(lbounds(1):, lbounds(2):), contiguous, intent(in) :: rho !< (i,j); density
  real(rk), dimension(lbounds(1):, lbounds(2):), contiguous, intent(in) :: u !< (i,j); density
  real(rk), dimension(lbounds(1):, lbounds(2):), contiguous, intent(in) :: v !< (i,j); density
  real(rk), dimension(lbounds(1):, lbounds(2):), contiguous, intent(in) :: p !< (i,j); density
end subroutine distinguish_continuous_regions

subroutine finalize(self)
  !< Finalizer routine to clean up allocated data
  type(muscl_mlp_t), intent(inout) :: self
  if (allocated(self%continuity_sensor)) deallocate(self%continuity_sensor)
end subroutine finalize

#:for DIR in DIRECTIONS
#:for ORDER in SPATIAL_ORDER
subroutine interp_muscl_mlp_${DIR}$_edge_${ORDER}$_order(self, q, lbounds, edge_values)
  class(muscl_mlp_t), intent(in) :: self
  integer(ik), dimension(2), intent(in) :: lbounds

  real(rk), dimension(lbounds(1):, lbounds(2):), contiguous, intent(in) :: q
  !< (i,j); primitive variable to reconstruct at the edge

  real(rk), dimension(:, :, :), allocatable, intent(out) :: edge_values
  !<((L,R), i, j); L/R state for each edge

  integer(ik) :: i, j
  integer(ik) :: ilo, ihi, jlo, jhi

  real(rk) :: delta_i_minus_half, delta_i_plus_half, delta_i_plus_three_half
  real(rk) :: r_R, r_L, phi_limit


  !dir$ assume_aligned q: __ALIGNBYTES__
  !dir$ assume_aligned edge_values: __ALIGNBYTES__

  if (enable_debug_print) call debug_print('Running muscl_tvd2_t%interp_muscl_mlp_${DIR}$_edge()', __FILE__, __LINE__)

  ! Because this is an edge-based array, the indexing is # cells + 1, and
  ! only goes into the single nearest ghost layer
  ilo = lbound(q, dim=1) + n_ghost_layers - 1
  jlo = lbound(q, dim=2) + n_ghost_layers - 1
  ihi = ubound(q, dim=1) - n_ghost_layers
  jhi = ubound(q, dim=2) - n_ghost_layers

  #:if DIR == 'i'
    allocate(edge_values(1:2, ilo-1:ihi, jlo:jhi))
  #:elif DIR == 'j'
    allocate(edge_values(1:2, ilo:ihi, jlo-1:jhi))
  #:endif

  edge_values = 0.0_rk
    !
    !                    jflux(i,j)  'R'
    !               o--------------------o
    !               |                'L' |
    !               |                    |
    ! iflux(i-1, j) |     cell (i,j)     | iflux(i, j)
    !               |                    |
    !               |                'L' | 'R'
    !               o--------------------o
    !                  jflux(i,j-1)
    !
    ! This is the numbering convention that this module uses

  !$omp parallel default(none), &
  !$omp firstprivate(ilo, ihi, jlo, jhi) &
  !$omp private(i, j, phi_limit, delta_i_minus_half, delta_i_plus_half, delta_i_plus_three_half) &
  !$omp private(r_L, r_R) &
  !$omp shared(q, edge_values)
  !$omp do
  do j = jlo, jhi
    !$omp simd __INTERP_ALIGN__
    !dir$ vector aligned
    do i = ilo, ihi

    #:if DIR == 'i'
      delta_i_minus_half = q(i, j) - q(i - 1, j)
      delta_i_plus_half = q(i + 1, j) - q(i, j)
      delta_i_plus_three_half = q(i + 2, j) - q(i + 1, j)
    #:elif DIR == 'j'
      delta_i_minus_half = q(i, j) - q(i, j - 1)
      delta_i_plus_half = q(i, j + 1) - q(i, j)
      delta_i_plus_three_half = q(i, j + 2) - q(i, j + 1)
    #:endif

      if (abs(delta_i_minus_half) < epsilon(1.0_rk)) delta_i_minus_half = 0.0_rk
      if (abs(delta_i_plus_half) < epsilon(1.0_rk)) delta_i_plus_half = 0.0_rk
      if (abs(delta_i_plus_three_half) < epsilon(1.0_rk)) delta_i_plus_three_half = 0.0_rk

      r_L = delta_i_plus_half / (delta_i_minus_half + 1e-16_rk)
      r_R = delta_i_plus_half / (delta_i_plus_three_half + 1e-16_rk)


    ! #:if ORDER == 3
    !   ! 3rd order interpolation
    !   beta_L = (1.0_rk + 2.0_rk * r_L_i) / 3.0_rk
    !   beta_R = (1.0_rk + 2.0_rk * r_R_ip1) / 3.0_rk
    ! #:elif ORDER == 5
    !   ! 5th order interpolation
    !   beta_L = ((-2.0_rk / r_L_im1) + 11.0_rk + (24.0_rk * r_L_i) - (3.0_rk * r_L_i * r_L_ip1)) / 30.0_rk
    !   beta_R = ((-2.0_rk / r_R_ip2) + 11.0_rk + (24.0_rk * r_R_ip1) - (3.0_rk * r_R_ip1 * r_R_i)) / 30.0_rk
    ! #:endif


    !   ! Apply the limiter
    ! #:if LIMITER == 'minmod'
    !   phi_limit = max(0.0_rk, min(r_L, 1.0_rk))
    ! #:elif LIMITER == 'superbee'
    !   phi_limit = max(0.0_rk, min(2.0_rk * r_L, 1.0_rk), min(r_L, 2.0_rk))
    ! #:elif LIMITER == 'vanleer'
    !   phi_limit = (r_L + abs(r_L)) / (1.0_rk + abs(r_L))
    ! #:endif

    !   ! Phi L, e.g. left state
    !   edge_values(1, i, j) = q(i, j) + 0.5_rk * phi_limit * delta_i_minus_half

    !   ! Apply the limiter
    ! #:if LIMITER == 'minmod'
    !   phi_limit = max(0.0_rk, min(r_R, 1.0_rk))
    ! #:elif LIMITER == 'superbee'
    !   phi_limit = max(0.0_rk, min(2.0_rk * r_R, 1.0_rk), min(r_R, 2.0_rk))
    ! #:elif LIMITER == 'vanleer'
    !   phi_limit = (r_R + abs(r_R)) / (1.0_rk + abs(r_R))
    ! #:endif

    !   ! Phi R, e.g. right state
    ! #:if DIR == 'i'
    !   edge_values(2, i, j) = q(i + 1, j) - 0.5_rk * phi_limit * delta_i_plus_three_half
    ! #:elif DIR == 'j'
    !   edge_values(2, i, j) = q(i, j + 1) - 0.5_rk * phi_limit * delta_i_plus_three_half
    ! #:endif

    end do
  end do
  !$omp end do
  !$omp end parallel

end subroutine interp_muscl_mlp_${DIR}$_edge_${ORDER}$_order

#:endfor
#:endfor
end module mod_muscl_mlp
