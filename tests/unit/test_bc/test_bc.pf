module test_bc
  use iso_fortran_env, only: ik => int32, rk => real64
  use mod_input, only: input_t
  use mod_bc_factory, only: bc_factory
  use mod_boundary_conditions, only: boundary_condition_t
  use mod_grid_factory, only: grid_factory
  use mod_grid, only: grid_t
  use funit

  implicit none

  integer(ik), parameter :: ni_nodes = 5
  integer(ik), parameter :: nj_nodes = 5
  integer(ik), parameter :: ni_cells = ni_nodes - 1
  integer(ik), parameter :: nj_cells = nj_nodes - 1
  integer(ik) :: alloc_status

contains

  @test
  subroutine test_bc_factory()
    class(boundary_condition_t), allocatable :: bc_plus_x
    class(boundary_condition_t), allocatable :: bc_plus_y
    class(boundary_condition_t), allocatable :: bc_minus_x
    class(boundary_condition_t), allocatable :: bc_minus_y

    type(input_t) :: input
    class(grid_t), allocatable :: grid
    real(rk), dimension(:, :, :), allocatable :: U
    real(rk), dimension(:, :, :, :, :), allocatable :: reconstructed_domain

    input = input_t(reconstruction_type='piecewise_linear', &
                    ni_nodes=ni_nodes, nj_nodes=nj_nodes, &
                    read_init_cond_from_file=.false., &
                    xmin=-2.0_rk, xmax=2.0_rk, ymin=-2.0_rk, ymax=2.0_rk)

    grid = grid_factory(input)

    ! These are normally handled by the fvleg puppeteer, but for now we make them ourselves
    associate(left=>grid%ilo_bc_cell, right=>grid%ihi_bc_cell, &
              bottom=>grid%jlo_bc_cell, top=>grid%jhi_bc_cell)

      allocate(U(4, left:right, bottom:top), stat=alloc_status)
      ! ((rho, u, v, p), i, j) Conserved variables for each cell
      if(alloc_status /= 0) error stop "Unable to allocate U"

      allocate(reconstructed_domain(4, 4, 2, left:right, bottom:top), stat=alloc_status)

      ! ((rho, u ,v, p), point, node/midpoint, i, j); this is a cell-based value, so right=ni-1, etc
      if(alloc_status /= 0) error stop "Unable to allocate reconstructed_domain"
    end associate

    bc_plus_x = bc_factory(bc_type='periodic', location='+x')
    bc_plus_y = bc_factory(bc_type='periodic', location='+y')
    bc_minus_x = bc_factory(bc_type='periodic', location='-x')
    bc_minus_y = bc_factory(bc_type='periodic', location='-y')

    @assertEqual('+x', bc_plus_x%location)
    @assertEqual('+y', bc_plus_y%location)
    @assertEqual('-x', bc_minus_x%location)
    @assertEqual('-y', bc_minus_y%location)

    ! Test the conserved var state
    U = 0.0_rk
    reconstructed_domain = 0.0_rk

    ! the boundary routines

    !   Domain cartoon layout
    !   |---||---|---|---|---||---|
    !   | 2 || 1 | 5 | 5 | 2 || 1 | <- j3; aka top_ghost (grid%jhi_bc_cell)
    !   |===||===|===|===|===||===|
    !   | 3 || 4 | 7 | 7 | 3 || 4 | <- j2; aka top (grid%jhi_cell)
    !   |---||---|---|---|---||---|
    !   | 6 || 8 | D | D | 6 || 8 |
    !   |---||---|---|---|---||---|
    !   | 6 || 8 | D | D | 6 || 8 |
    !   |---||---|---|---|---||---|
    !   | 2 || 1 | 5 | 5 | 2 || 1 | <- j1; aka bottom (grid%jlo_cell)
    !   |===||===|===|===|===||===|
    !   | 3 || 4 | 7 | 7 | 3 || 4 | <- j0; aka bottom_ghost (grid%jlo_bc_cell)
    !   |---||---|---|---|---||---|
    !    i0   i1  i2  i3  i4   i5

    ! i0; aka left_ghost, grid%ilo_bc_cell
    ! i1; aka left, grid%ilo_cell
    ! i4; aka right, grid%ihi_cell
    ! i5; aka right_ghost grid%ihi_bc_cell

    !  . : ghost cell (aka boundary cell)
    !  x : physical domain cell
    !  D : unaffected central cell

    ! Set unique values along the (real) edges so I can test the bc routines
    associate(left=>grid%ilo_cell, right=>grid%ihi_cell, &
              bottom=>grid%jlo_cell, top=>grid%jhi_cell)

      U(:, left:right, bottom) = 5.0_rk ! "5" cells in cartoon
      U(:, left:right, top) = 7.0_rk    ! "7" cells in cartoon
      U(:, left, bottom:top) = 8.0_rk   ! "8" cells in cartoon
      U(:, right, bottom:top) = 6.0_rk  ! "6" cells in cartoon
      U(:, left, bottom) = 1.0_rk       ! "1" cells in cartoon
      U(:, left, top) = 4.0_rk          ! "4" cells in cartoon
      U(:, right, bottom) = 2.0_rk      ! "2" cells in cartoon
      U(:, right, top) = 3.0_rk         ! "3" cells in cartoon

      reconstructed_domain(:, :, :, left:right, bottom) = 5.0_rk ! "5" cells in cartoon
      reconstructed_domain(:, :, :, left:right, top) = 7.0_rk    ! "7" cells in cartoon
      reconstructed_domain(:, :, :, right, bottom:top) = 6.0_rk  ! "6" cells in cartoon
      reconstructed_domain(:, :, :, left, bottom:top) = 8.0_rk   ! "8" cells in cartoon
      reconstructed_domain(:, :, :, left, bottom) = 1.0_rk       ! "1" cells in cartoon
      reconstructed_domain(:, :, :, left, top) = 4.0_rk          ! "4" cells in cartoon
      reconstructed_domain(:, :, :, right, bottom) = 2.0_rk      ! "2" cells in cartoon
      reconstructed_domain(:, :, :, right, top) = 3.0_rk         ! "3" cells in cartoon
    end associate

    call bc_plus_x%apply_bc(conserved_vars=U, reconstructed_state=reconstructed_domain)
    call bc_plus_y%apply_bc(conserved_vars=U, reconstructed_state=reconstructed_domain)
    call bc_minus_x%apply_bc(conserved_vars=U, reconstructed_state=reconstructed_domain)
    call bc_minus_y%apply_bc(conserved_vars=U, reconstructed_state=reconstructed_domain)

    associate(left=>grid%ilo_cell, right=>grid%ihi_cell, &
              bottom=>grid%jlo_cell, top=>grid%jhi_cell, &
              left_ghost=>grid%ilo_bc_cell, right_ghost=>grid%ihi_bc_cell, &
              bottom_ghost=>grid%jlo_bc_cell, top_ghost=>grid%jhi_bc_cell)

      ! bottom ghost layer
      @assertEqual([3.0_rk, 4.0_rk, 7.0_rk, 7.0_rk, 3.0_rk, 4.0_rk], U(1, :, bottom_ghost))
      @assertEqual([3.0_rk, 4.0_rk, 7.0_rk, 7.0_rk, 3.0_rk, 4.0_rk], reconstructed_domain(1, 1, 1, :, bottom_ghost))

      ! top ghost layer
      @assertEqual([2.0_rk, 1.0_rk, 5.0_rk, 5.0_rk, 2.0_rk, 1.0_rk], U(1, :, top_ghost))
      @assertEqual([2.0_rk, 1.0_rk, 5.0_rk, 5.0_rk, 2.0_rk, 1.0_rk], reconstructed_domain(1, 1, 1, :, top_ghost))

      ! left ghost layer
      @assertEqual([3.0_rk, 2.0_rk, 6.0_rk, 6.0_rk, 3.0_rk, 2.0_rk], U(1, left_ghost, :))
      @assertEqual([3.0_rk, 2.0_rk, 6.0_rk, 6.0_rk, 3.0_rk, 2.0_rk], reconstructed_domain(1, 1, 1, left_ghost, :))

      ! right ghost layer
      @assertEqual([4.0_rk, 1.0_rk, 8.0_rk, 8.0_rk, 4.0_rk, 1.0_rk], U(1, right_ghost, :))
      @assertEqual([4.0_rk, 1.0_rk, 8.0_rk, 8.0_rk, 4.0_rk, 1.0_rk], reconstructed_domain(1, 1, 1, right_ghost, :))
    end associate
  end subroutine

end module test_bc
