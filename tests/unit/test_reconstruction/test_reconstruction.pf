module test_reconstruction
  use, intrinsic :: iso_fortran_env, only: ik => int32, rk => real64
  use mod_input, only: input_t
  use mod_abstract_reconstruction, only: abstract_reconstruction_t
  use mod_reconstruction_factory, only: reconstruction_factory
  use mod_edge_interpolator, only: edge_iterpolator_t
  use mod_tvd_2nd_order, only: tvd_2nd_order_t
  use mod_tvd_3rd_order, only: tvd_3rd_order_t
  use mod_tvd_5th_order, only: tvd_5th_order_t
  use mod_mlp_3rd_order, only: mlp_3rd_order_t
  use mod_mlp_5th_order, only: mlp_5th_order_t
  use mod_grid_factory, only: grid_factory
  use mod_grid, only: grid_t
  use funit

  implicit none

  integer(ik), parameter :: ni_nodes = 5
  integer(ik), parameter :: nj_nodes = 5
  integer(ik), parameter :: ni_cells = ni_nodes - 1
  integer(ik), parameter :: nj_cells = nj_nodes - 1
  real(rk), parameter :: xmin = -2.0_rk
  real(rk), parameter :: xmax = 2.0_rk
  real(rk), parameter :: ymin = -2.0_rk
  real(rk), parameter :: ymax = 2.0_rk
  integer(ik) :: alloc_stat
  integer(ik), parameter :: C1 = 1
  integer(ik), parameter :: M1 = 2
  integer(ik), parameter :: C2 = 3
  integer(ik), parameter :: M2 = 4
  integer(ik), parameter :: C3 = 5
  integer(ik), parameter :: M3 = 6
  integer(ik), parameter :: C4 = 7
  integer(ik), parameter :: M4 = 8

  class(grid_t), pointer :: grid
  class(abstract_reconstruction_t), allocatable :: reconstruction_operator
  type(input_t) :: input

  real(rk), dimension(0:ni_cells - 1, 0:nj_cells - 1) :: rho = 0.0_rk
  real(rk), dimension(0:ni_cells - 1, 0:nj_cells - 1) :: u = 0.0_rk
  real(rk), dimension(0:ni_cells - 1, 0:nj_cells - 1) :: v = 0.0_rk
  real(rk), dimension(0:ni_cells - 1, 0:nj_cells - 1) :: p = 0.0_rk

  real(rk), dimension(1:8, 0:ni_cells - 1, 0:nj_cells - 1) :: recon_rho
  real(rk), dimension(1:8, 0:ni_cells - 1, 0:nj_cells - 1) :: recon_u
  real(rk), dimension(1:8, 0:ni_cells - 1, 0:nj_cells - 1) :: recon_v
  real(rk), dimension(1:8, 0:ni_cells - 1, 0:nj_cells - 1) :: recon_p

contains

  @before
  subroutine before()
  end subroutine

  @after
  subroutine after()
    if(associated(grid)) deallocate(grid)
    if(allocated(reconstruction_operator)) deallocate(reconstruction_operator)
  end subroutine

  ! @test
  ! subroutine test_piecewise_linear()

  !   class(abstract_reconstruction_t), pointer :: r_omega => null()
  !   integer(ik) :: i, j

  !   write(*, *) "Testing the piecewise_linear with TVD2 edge iterpolation and 'none' flux limiter"

  !   input = input_t(cell_reconstruction='piecewise_linear', &
  !                   edge_interpolation_scheme='TVD2', &
  !                   limiter='none', &
  !                   gradient_scheme='green_gauss', &
  !                   ni_nodes=ni_nodes, nj_nodes=nj_nodes, &
  !                   read_init_cond_from_file=.false., &
  !                   xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax)
  !   grid => grid_factory(input)

  !   r_omega => reconstruction_factory(input=input, grid_target=grid)
  !   allocate(reconstruction_operator, source=r_omega)
  !   deallocate(r_omega)

  !   !                Domain           -->                Primitive Variable
  !   ! |-------||-------|-------||-------|  -->  |-------||-------|-------||-------|
  !   ! | (0,3) || (1,3) | (2,3) || (3,3) |  -->  |   1   ||   2   |   3   ||   4   |
  !   ! |=======||=======|=======||=======|  -->  |=======||=======|=======||=======|
  !   ! | (0,2) || (1,2) | (2,2) || (3,2) |  -->  |   1   ||   2   |   3   ||   4   |
  !   ! |-------||-------|-------||-------|  -->  |-------||-------|-------||-------|
  !   ! | (0,1) || (1,1) | (2,1) || (3,1) |  -->  |   1   ||   2   |   3   ||   4   |
  !   ! |=======||=======|=======||=======|  -->  |=======||=======|=======||=======|
  !   ! | (0,0) || (1,0) | (2,0) || (3,0) |  -->  |   1   ||   2   |   3   ||   4   |
  !   ! |-------||-------|-------||-------|  -->  |-------||-------|-------||-------|

  !   rho(0, :) = 1.0_rk
  !   rho(1, :) = 2.0_rk
  !   rho(2, :) = 3.0_rk
  !   rho(3, :) = 4.0_rk

  !   u = 0.0_rk
  !   v = 0.0_rk
  !   p = 1.0_rk

  !   call reconstruction_operator%set_cell_average_pointers(rho=rho, p=p, lbounds=lbound(p))
  !   call reconstruction_operator%reconstruct(primitive_var=rho, &
  !                                            reconstructed_var=recon_rho, &
  !                                            lbounds=lbound(rho), &
  !                                            name='rho', stage_name='test_1')
  !   call reconstruction_operator%reconstruct(primitive_var=u, &
  !                                            reconstructed_var=recon_u, &
  !                                            lbounds=lbound(p), &
  !                                            name='u', stage_name='test_1')
  !   call reconstruction_operator%reconstruct(primitive_var=v, &
  !                                            reconstructed_var=recon_v, &
  !                                            lbounds=lbound(v), &
  !                                            name='v', stage_name='test_1')
  !   call reconstruction_operator%reconstruct(primitive_var=p, &
  !                                            reconstructed_var=recon_p, &
  !                                            lbounds=lbound(p), &
  !                                            name='p', stage_name='test_1')

  !   i = 1
  !   j = 1
  !   associate(cell_ave=>rho(i, j), &
  !             E1=>edge_vars(1, i, j), &
  !             E2=>edge_vars(2, i, j), &
  !             E3=>edge_vars(3, i, j), &
  !             E4=>edge_vars(4, i, j))
  !     write(*, '(a)') "*********************************************"
  !     write(*, '(a)') "Interpolated edge state for: rho"
  !     write(*, '(a)') "*********************************************"
  !     write(*, *)
  !     write(*, '(16x,es11.3)') E3
  !     write(*, *) "           C---------E3---------C"
  !     write(*, *) "           |                    |"
  !     write(*, *) "           |                    |"
  !     write(*, '((12x,a,es11.3,a))') "|    ", cell_ave, "     |"
  !     write(*, '(2(es11.3,a))') E4, " E4       (i,j)      E2", E2
  !     write(*, *) "           |                    |"
  !     write(*, *) "           |                    |"
  !     write(*, *) "           |                    |"
  !     write(*, *) "           C---------E1---------C"
  !     write(*, '(16x,es11.3)') E1
  !     write(*, *)
  !   end associate

  !   if (associated(grid)) deallocate(grid)
  !   if (allocated(reconstruction_operator)) deallocate(reconstruction_operator)

  ! end subroutine test_piecewise_linear

  @test
  subroutine test_tvd2_none()

    class(edge_iterpolator_t), allocatable :: edge_interpolator
    real(rk), dimension(:, :, :), allocatable :: edge_vars
    integer(ik) :: i, j

    write(*, *) "Testing the TVD2 edge iterpolation and 'none' flux limiter"
    allocate(tvd_2nd_order_t :: edge_interpolator)
    call edge_interpolator%initialize(limiter='none')

    !                Domain           -->                Primitive Variable
    ! |-------||-------|-------||-------|  -->  |-------||-------|-------||-------|
    ! | (0,3) || (1,3) | (2,3) || (3,3) |  -->  |   1   ||   2   |   3   ||   4   |
    ! |=======||=======|=======||=======|  -->  |=======||=======|=======||=======|
    ! | (0,2) || (1,2) | (2,2) || (3,2) |  -->  |   1   ||   2   |   3   ||   4   |
    ! |-------||-------|-------||-------|  -->  |-------||-------|-------||-------|
    ! | (0,1) || (1,1) | (2,1) || (3,1) |  -->  |   1   ||   2   |   3   ||   4   |
    ! |=======||=======|=======||=======|  -->  |=======||=======|=======||=======|
    ! | (0,0) || (1,0) | (2,0) || (3,0) |  -->  |   1   ||   2   |   3   ||   4   |
    ! |-------||-------|-------||-------|  -->  |-------||-------|-------||-------|

    rho(0, :) = 1.0_rk
    rho(1, :) = 2.0_rk
    rho(2, :) = 3.0_rk
    rho(3, :) = 4.0_rk

    call edge_interpolator%interpolate_edge_values(q=rho, &
                                                   lbounds=lbound(rho), &
                                                   edge_values=edge_vars)

    i = 2
    j = 2
    associate(cell_ave => rho(i, j), &
              E1 => edge_vars(1, i, j), &
              E2 => edge_vars(2, i, j), &
              E3 => edge_vars(3, i, j), &
              E4 => edge_vars(4, i, j))
      write(*, '(a)') "*********************************************"
      write(*, '(a)') "Interpolated edge state for: rho"
      write(*, '(a)') "*********************************************"
      write(*, *)
      write(*, '(16x,es11.3)') E3
      write(*, *) "           C---------E3---------C"
      write(*, *) "           |                    |"
      write(*, *) "           |                    |"
      write(*, '((12x,a,es11.3,a))') "|    ", cell_ave, "     |"
      write(*, '(2(es11.3,a))') E4, " E4       (i,j)      E2", E2
      write(*, *) "           |                    |"
      write(*, *) "           |                    |"
      write(*, *) "           |                    |"
      write(*, *) "           C---------E1---------C"
      write(*, '(16x,es11.3)') E1
      write(*, *)

    end associate

    @assertEqual(3.0_rk, edge_vars(1, i, j))
    @assertEqual(3.5_rk, edge_vars(2, i, j))
    @assertEqual(3.0_rk, edge_vars(3, i, j))
    @assertEqual(2.5_rk, edge_vars(4, i, j))

  end subroutine test_tvd2_none

  ! @test
  subroutine test_tvd3()

    class(edge_iterpolator_t), allocatable :: edge_interpolator
    real(rk), dimension(:, :, :), allocatable :: edge_vars
    integer(ik) :: i, j

    write(*, *) "Testing the TVD3 edge iterpolation"
    allocate(tvd_3rd_order_t :: edge_interpolator)
    call edge_interpolator%initialize(limiter='none')

    !                Domain           -->                Primitive Variable
    ! |-------||-------|-------||-------|  -->  |-------||-------|-------||-------|
    ! | (0,3) || (1,3) | (2,3) || (3,3) |  -->  |   1   ||   2   |   3   ||   4   |
    ! |=======||=======|=======||=======|  -->  |=======||=======|=======||=======|
    ! | (0,2) || (1,2) | (2,2) || (3,2) |  -->  |   1   ||   2   |   3   ||   4   |
    ! |-------||-------|-------||-------|  -->  |-------||-------|-------||-------|
    ! | (0,1) || (1,1) | (2,1) || (3,1) |  -->  |   1   ||   2   |   3   ||   4   |
    ! |=======||=======|=======||=======|  -->  |=======||=======|=======||=======|
    ! | (0,0) || (1,0) | (2,0) || (3,0) |  -->  |   1   ||   2   |   3   ||   4   |
    ! |-------||-------|-------||-------|  -->  |-------||-------|-------||-------|

    rho(0, :) = 1.0_rk
    rho(1, :) = 2.0_rk
    rho(2, :) = 3.0_rk
    rho(3, :) = 4.0_rk

    call edge_interpolator%interpolate_edge_values(q=rho, &
                                                   lbounds=lbound(rho), &
                                                   edge_values=edge_vars)

    i = 2
    j = 2
    associate(cell_ave => rho(i, j), &
              E1 => edge_vars(1, i, j), &
              E2 => edge_vars(2, i, j), &
              E3 => edge_vars(3, i, j), &
              E4 => edge_vars(4, i, j))
      write(*, '(a)') "*********************************************"
      write(*, '(a)') "Interpolated edge state for: rho"
      write(*, '(a)') "*********************************************"
      write(*, *)
      write(*, '(16x,es11.3)') E3
      write(*, *) "           C---------E3---------C"
      write(*, *) "           |                    |"
      write(*, *) "           |                    |"
      write(*, '((12x,a,es11.3,a))') "|    ", cell_ave, "     |"
      write(*, '(2(es11.3,a))') E4, " E4       (i,j)      E2", E2
      write(*, *) "           |                    |"
      write(*, *) "           |                    |"
      write(*, *) "           |                    |"
      write(*, *) "           C---------E1---------C"
      write(*, '(16x,es11.3)') E1
      write(*, *)

    end associate

    @assertEqual(3.0_rk, edge_vars(1, i, j))
    @assertEqual(3.5_rk, edge_vars(2, i, j))
    @assertEqual(3.0_rk, edge_vars(3, i, j))
    @assertEqual(2.5_rk, edge_vars(4, i, j))

  end subroutine test_tvd3

  ! @test
  subroutine test_mlp3()

    class(edge_iterpolator_t), allocatable :: edge_interpolator
    real(rk), dimension(:, :, :), allocatable :: edge_vars
    integer(ik) :: i, j

    write(*, *) "Testing the MLP3 edge iterpolation"
    allocate(mlp_3rd_order_t :: edge_interpolator)
    call edge_interpolator%initialize(limiter='none')

    !                Domain           -->                Primitive Variable
    ! |-------||-------|-------||-------|  -->  |-------||-------|-------||-------|
    ! | (0,3) || (1,3) | (2,3) || (3,3) |  -->  |   1   ||   2   |   3   ||   4   |
    ! |=======||=======|=======||=======|  -->  |=======||=======|=======||=======|
    ! | (0,2) || (1,2) | (2,2) || (3,2) |  -->  |   1   ||   2   |   3   ||   4   |
    ! |-------||-------|-------||-------|  -->  |-------||-------|-------||-------|
    ! | (0,1) || (1,1) | (2,1) || (3,1) |  -->  |   1   ||   2   |   3   ||   4   |
    ! |=======||=======|=======||=======|  -->  |=======||=======|=======||=======|
    ! | (0,0) || (1,0) | (2,0) || (3,0) |  -->  |   1   ||   2   |   3   ||   4   |
    ! |-------||-------|-------||-------|  -->  |-------||-------|-------||-------|

    rho(0, :) = 1.0_rk
    rho(1, :) = 2.0_rk
    rho(2, :) = 3.0_rk
    rho(3, :) = 4.0_rk

    call edge_interpolator%interpolate_edge_values(q=rho, &
                                                   lbounds=lbound(rho), &
                                                   edge_values=edge_vars)

    i = 2
    j = 2
    associate(cell_ave => rho(i, j), &
              E1 => edge_vars(1, i, j), &
              E2 => edge_vars(2, i, j), &
              E3 => edge_vars(3, i, j), &
              E4 => edge_vars(4, i, j))
      write(*, '(a)') "*********************************************"
      write(*, '(a)') "Interpolated edge state for: rho"
      write(*, '(a)') "*********************************************"
      write(*, *)
      write(*, '(16x,es11.3)') E3
      write(*, *) "           C---------E3---------C"
      write(*, *) "           |                    |"
      write(*, *) "           |                    |"
      write(*, '((12x,a,es11.3,a))') "|    ", cell_ave, "     |"
      write(*, '(2(es11.3,a))') E4, " E4       (i,j)      E2", E2
      write(*, *) "           |                    |"
      write(*, *) "           |                    |"
      write(*, *) "           |                    |"
      write(*, *) "           C---------E1---------C"
      write(*, '(16x,es11.3)') E1
      write(*, *)

    end associate

    @assertEqual(3.0_rk, edge_vars(1, i, j))
    @assertEqual(3.5_rk, edge_vars(2, i, j))
    @assertEqual(3.0_rk, edge_vars(3, i, j))
    @assertEqual(2.5_rk, edge_vars(4, i, j))

  end subroutine test_mlp3
end module test_reconstruction
