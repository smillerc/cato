module test_grid
  use, intrinsic :: iso_fortran_env, only: ik => int32, rk => real64, stdout => output_unit
  use mod_regular_2d_grid, only: regular_2d_grid_t
  use mod_grid, only: grid_t
  use mod_grid_factory, only: grid_factory
  use mod_input, only: input_t
  use funit

  implicit none

  integer(ik), parameter :: ni_nodes = 5
  integer(ik), parameter :: nj_nodes = 3
  integer(ik), parameter :: ni_cells = ni_nodes - 1
  integer(ik), parameter :: nj_cells = nj_nodes - 1
  real(rk), parameter :: xmin = -2.0_rk
  real(rk), parameter :: xmax = 2.0_rk
  real(rk), parameter :: ymin = -2.0_rk
  real(rk), parameter :: ymax = 2.0_rk
  integer(ik) :: alloc_stat

contains

  @test
  subroutine test_corner_edge_vector_query()

    class(grid_t), pointer :: grid
    type(input_t) :: input

    real(rk), dimension(2, 2, 4) :: actual_corner_vectors, grid_corner_vectors

    print *, 'Testing test_corner_edge_vector_query()'
    input = input_t(reconstruction_type='piecewise_linear', &
                    ni_nodes=ni_nodes, nj_nodes=nj_nodes, &
                    read_init_cond_from_file=.false., &
                    xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax)

    grid => grid_factory(input)

    grid_corner_vectors = grid%get_corner_vectors(cell_ij=[1, 1], corner='lower-left')
    actual_corner_vectors = reshape([[-2.0_rk, -2.0_rk], &  ! (x,y) tail, vector 1
                                     [-2.0_rk, -4.0_rk], & ! (x,y) head, vector 1
                                     [-2.0_rk, -2.0_rk], &  ! (x,y) tail, vector 2
                                     [-1.0_rk, -2.0_rk], &  ! (x,y) head, vector 2
                                     [-2.0_rk, -2.0_rk], &  ! (x,y) tail, vector 3
                                     [-2.0_rk, 0.0_rk], &  ! (x,y) head, vector 3
                                     [-2.0_rk, -2.0_rk], &  ! (x,y) tail, vector 4
                                     [-3.0_rk, -2.0_rk] &  ! (x,y) head, vector 4
                                     ], shape=[2, 2, 4])

    @assertEqual(actual_corner_vectors, grid_corner_vectors)
    deallocate(grid)
  end subroutine test_corner_edge_vector_query

  @test
  subroutine test_leftright_midpoint_edge_vector_query()

    class(grid_t), pointer :: grid
    type(input_t) :: input

    real(rk), dimension(2, 2, 2) :: actual_midpoint_vectors !< ((x,y), (tail,head), (vector1:vector2))
    real(rk), dimension(2, 2, 2) :: grid_midpoint_vectors !< ((x,y), (tail,head), (vector1:vector2))

    print *, 'Testing test_leftright_midpoint_edge_vector_query()'
    input = input_t(reconstruction_type='piecewise_linear', &
                    ni_nodes=ni_nodes, nj_nodes=nj_nodes, &
                    read_init_cond_from_file=.false., &
                    xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax)

    grid => grid_factory(input)

    grid_midpoint_vectors = grid%get_midpoint_vectors(cell_ij=[1, 1], edge='bottom')
    actual_midpoint_vectors = reshape([[-1.5_rk, -2.0_rk], &  ! (x,y) tail, vector 1
                                       [-2.0_rk, -2.0_rk], &  ! (x,y) head, vector 1
                                       [-1.5_rk, -2.0_rk], &  ! (x,y) tail, vector 2
                                       [-1.0_rk, -2.0_rk] &  ! (x,y) head, vector 2
                                       ], shape=[2, 2, 2])

    @assertEqual(actual_midpoint_vectors, grid_midpoint_vectors)
    deallocate(grid)
  end subroutine test_leftright_midpoint_edge_vector_query

  @test
  subroutine test_downup_midpoint_edge_vector_query()

    class(grid_t), pointer :: grid
    type(input_t) :: input

    real(rk), dimension(2, 2, 2) :: actual_midpoint_vectors !< ((x,y), (tail,head), (vector1:vector2))
    real(rk), dimension(2, 2, 2) :: grid_midpoint_vectors !< ((x,y), (tail,head), (vector1:vector2))

    print *, 'Testing test_downup_midpoint_edge_vector_query()'
    input = input_t(reconstruction_type='piecewise_linear', &
                    ni_nodes=ni_nodes, nj_nodes=nj_nodes, &
                    read_init_cond_from_file=.false., &
                    xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax)

    grid => grid_factory(input)

    grid_midpoint_vectors = grid%get_midpoint_vectors(cell_ij=[1, 1], edge='left')
    actual_midpoint_vectors = reshape([[-2.0_rk, -1.0_rk], &  ! (x,y) tail, vector 1
                                       [-2.0_rk, -2.0_rk], &  ! (x,y) head, vector 1
                                       [-2.0_rk, -1.0_rk], &  ! (x,y) tail, vector 2
                                       [-2.0_rk, 0.0_rk] &  ! (x,y) head, vector 2
                                       ], shape=[2, 2, 2])

    @assertEqual(actual_midpoint_vectors, grid_midpoint_vectors)
    deallocate(grid)
  end subroutine test_downup_midpoint_edge_vector_query

  @test
  subroutine test_init_from_ini()

    class(grid_t), pointer :: grid
    type(input_t) :: input
    integer(ik) :: ini
    character(:), allocatable :: ini_filename

    write(*, *) "Running test for test_grid.test_init_from_ini()"

    ini_filename = 'test_grid_test_init_from_ini.ini'

    open(newunit=ini, file=ini_filename, status='replace')
    write(ini, *) "[general]"
    write(ini, *) "title='simple ini input'"
    write(ini, *) "[time]"
    write(ini, *) "max_time = 0.2"
    write(ini, *) "integration_strategy='rk2'"
    write(ini, *) "contour_interval_dt = 0.1"
    write(ini, *) "initial_delta_t = 1e-2"
    write(ini, *) "[grid]"
    write(ini, *) "xmin=", xmin
    write(ini, *) "xmax=", xmax
    write(ini, *) "ni_nodes=", ni_nodes
    write(ini, *) "nj_nodes=", nj_nodes
    write(ini, *) "ymin=", ymin
    write(ini, *) "ymax=", ymax
    write(ini, *) "[reference_state]"
    write(ini, *) "reference_time=1.0"
    write(ini, *) "reference_length=1.0"
    write(ini, *) "reference_density=1.0"
    write(ini, *) "[physics]"
    write(ini, *) "polytropic_index=1.6"
    write(ini, *) "[initial_conditions]"
    write(ini, *) "read_from_file = false"
    write(ini, *) "plus_x = 'periodic'"
    write(ini, *) "minus_x = 'periodic'"
    write(ini, *) "plus_y = 'periodic'"
    write(ini, *) "minus_y = 'periodic'"
    write(ini, *) "[scheme]"
    write(ini, *) "tau = '1e-2'"
    write(ini, *) "reconstruction_type = 'piecewise_linear'"
    write(ini, *) "slope_limiter = 'upwind'"
    write(ini, *) "[io]"
    write(ini, *) "contour_format = 'xdmf'"
    close(ini)

    call input%read_from_ini(ini_filename)
    grid => grid_factory(input)
    call test_grid_bounds(grid)
    deallocate(grid)

  end subroutine test_init_from_ini

  @test
  subroutine test_init_from_h5()
    class(grid_t), pointer :: grid
    type(input_t) :: input

    input = input_t(reconstruction_type='piecewise_linear', &
                    ni_nodes=ni_nodes, nj_nodes=nj_nodes, &
                    read_init_cond_from_file=.true., &
                    initial_condition_file='simple.h5', &
                    xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax)

    grid => grid_factory(input)
    call test_grid_bounds(grid)
    deallocate(grid)
  end subroutine test_init_from_h5

  subroutine test_grid_bounds(grid)

    class(grid_t), intent(in) :: grid
    ! type(input_t) :: input

    @assertEqual(5, grid%ni_node)
    @assertEqual(3, grid%nj_node)

    @assertEqual(4, grid%ni_cell)
    @assertEqual(2, grid%nj_cell)

    @assertEqual(1, grid%ilo_node)
    @assertEqual(5, grid%ihi_node)
    @assertEqual(1, grid%ilo_cell)
    @assertEqual(4, grid%ihi_cell)

    @assertEqual(1, grid%jlo_node)
    @assertEqual(3, grid%jhi_node)
    @assertEqual(1, grid%jlo_cell)
    @assertEqual(2, grid%jhi_cell)

    @assertEqual(0, grid%ilo_bc_node)
    @assertEqual(0, grid%jlo_bc_node)
    @assertEqual(0, grid%ilo_bc_cell)
    @assertEqual(0, grid%jlo_bc_cell)

    @assertEqual(6, grid%ihi_bc_node)
    @assertEqual(4, grid%jhi_bc_node)
    @assertEqual(5, grid%ihi_bc_cell)
    @assertEqual(3, grid%jhi_bc_cell)

    @assertEqual(1.0_rk, grid%min_dx)
    @assertEqual(2.0_rk, grid%min_dy)

    ! Check spacing in y (real domain)
    @assertEqual([-2.0_rk, 0.0_rk, 2.0_rk],[grid%get_y(1, 1), grid%get_y(1, 2), grid%get_y(1, 3)])
    ! Check spacing in y (ghost/boundary domain)
    @assertEqual([-4.0_rk, 4.0_rk],[grid%get_y(0, 0), grid%get_y(0, 4)])

    ! Check spacing in x (real domain)
    ! @assertEqual([-2.0_rk, -1.0_rk, 0.0_rk, 1.0_rk, 2.0_rk],
    ! [grid%get_x(1,1), grid%get_x(2,1), grid%get_x(3,1), grid%get_x(4,1), grid%get_x(5,1)])
    @assertEqual([-2.0_rk, -1.0_rk, 0.0_rk, 1.0_rk, 2.0_rk], grid%node_x(1:5, 1))
    ! Check spacing in y (ghost/boundary domain)
    @assertEqual([-3.0_rk, 3.0_rk],[grid%get_x(0, 0), grid%get_x(6, 0)])

    @assertEqual(2.0_rk, grid%get_cell_volumes(1, 1))
    @assertEqual(2.0_rk, grid%get_cell_volumes(grid%ilo_bc_cell, grid%jlo_bc_cell))
    @assertEqual(2.0_rk, grid%get_cell_volumes(grid%ihi_bc_cell, grid%jhi_bc_cell))

    ! ((x,y), (point_1: point_4), (corner, midpoint), i, j)
    @assertEqual([-2.0_rk, -2.0_rk], grid%cell_node_xy(:, 1, 1, 1, 1))
    @assertEqual([-1.0_rk, -2.0_rk], grid%cell_node_xy(:, 2, 1, 1, 1))
    @assertEqual([-1.0_rk, 0.0_rk], grid%cell_node_xy(:, 3, 1, 1, 1))
    @assertEqual([-2.0_rk, 0.0_rk], grid%cell_node_xy(:, 4, 1, 1, 1))

    @assertEqual([-1.5_rk, -2.0_rk], grid%cell_node_xy(:, 1, 2, 1, 1))
    @assertEqual([-1.0_rk, -1.0_rk], grid%cell_node_xy(:, 2, 2, 1, 1))
    @assertEqual([-1.5_rk, 0.0_rk], grid%cell_node_xy(:, 3, 2, 1, 1))
    @assertEqual([-2.0_rk, -1.0_rk], grid%cell_node_xy(:, 4, 2, 1, 1))

    ! Check bounds and shape
    @assertEqual([ni_cells + 2, nj_cells + 2], shape(grid%cell_volume))
    @assertEqual([0, 0], lbound(grid%cell_volume))
    @assertEqual([ni_cells + 1, nj_cells + 1], ubound(grid%cell_volume))

    @assertEqual([2, ni_cells + 2, nj_cells + 2], shape(grid%cell_centroid_xy))
    @assertEqual([1, 0, 0], lbound(grid%cell_centroid_xy))
    @assertEqual([2, ni_cells + 1, nj_cells + 1], ubound(grid%cell_centroid_xy))

    @assertEqual([4, ni_cells + 2, nj_cells + 2], shape(grid%cell_edge_lengths))
    @assertEqual([1, 0, 0], lbound(grid%cell_edge_lengths))
    @assertEqual([4, ni_cells + 1, nj_cells + 1], ubound(grid%cell_edge_lengths))

    @assertEqual([2, 4, ni_cells + 2, nj_cells + 2], shape(grid%cell_edge_norm_vectors))
    @assertEqual([1, 1, 0, 0], lbound(grid%cell_edge_norm_vectors))
    @assertEqual([2, 4, ni_cells + 1, nj_cells + 1], ubound(grid%cell_edge_norm_vectors))

    @assertEqual([2, 4, 2, ni_cells + 2, nj_cells + 2], shape(grid%cell_node_xy))
    @assertEqual([1, 1, 1, 0, 0], lbound(grid%cell_node_xy))
    @assertEqual([2, 4, 2, ni_cells + 1, nj_cells + 1], ubound(grid%cell_node_xy))

  end subroutine test_grid_bounds
end module test_grid
