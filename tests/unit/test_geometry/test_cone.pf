module test_cone
  use, intrinsic :: iso_fortran_env, only: ik => int32, rk => real64
  use mod_geometry
  use funit

  implicit none

contains

  @test
  subroutine test_intersection_points()

    real(rk), dimension(2, 2) :: line_xy !< ((x,y), (point_1, point_2))
    real(rk), dimension(2) :: circle_xy !< (x,y)
    real(rk) :: circle_radius
    real(rk), dimension(2, 2) :: intersection_xy !< ((x,y), (point_1, point_2))
    logical, dimension(2) :: valid_intersection !< (point_1, point_2)
    real(rk), dimension(2) :: angles

    circle_xy = [0.0_rk, 0.0_rk]
    circle_radius = 1e-5_rk

    print *, "Running test_intersection_points()"
    ! Exactly 2 intersections on a small circle at the origin
    line_xy(:, 1) = [-1.0_rk, 0.0_rk]
    line_xy(:, 2) = [1.0_rk, 0.0_rk]
    call find_line_circle_intersections(line_xy, circle_xy, circle_radius, intersection_xy, valid_intersection)
    @assertEqual([-circle_radius, 0.0_rk], intersection_xy(:, 1), 1e-10_rk)
    @assertEqual([circle_radius, 0.0_rk], intersection_xy(:, 2), 1e-10_rk)
    @assertEqual([.true., .true.], valid_intersection)
    angles(1) = intersection_angle_from_x_axis(circle_xy, intersection_xy(:, 1))
    angles(2) = intersection_angle_from_x_axis(circle_xy, intersection_xy(:, 2))
    @assertEqual([pi, 0.0_rk], angles)

    circle_xy = [1.0_rk, 1.0_rk]
    circle_radius = 2.0_rk
    ! No intersections
    line_xy(:, 1) = [1.0_rk, 0.0_rk]
    line_xy(:, 2) = [1.0_rk, 2.0_rk]
    call find_line_circle_intersections(line_xy, circle_xy, circle_radius, intersection_xy, valid_intersection)
    @assertEqual([1.0_rk, -1.0_rk], intersection_xy(:, 1))
    @assertEqual([1.0_rk, 3.0_rk], intersection_xy(:, 2))
    @assertEqual([.false., .false.], valid_intersection)
    angles(1) = intersection_angle_from_x_axis(circle_xy, intersection_xy(:, 1))
    angles(2) = intersection_angle_from_x_axis(circle_xy, intersection_xy(:, 2))
    @assertEqual([-0.5_rk * pi, 0.5_rk * pi], angles)

    ! Exactly 2 intersections on the circle
    line_xy(:, 1) = [1.0_rk, -1.0_rk]
    line_xy(:, 2) = [1.0_rk, 3.0_rk]
    call find_line_circle_intersections(line_xy, circle_xy, circle_radius, intersection_xy, valid_intersection)
    @assertEqual([1.0_rk, -1.0_rk], intersection_xy(:, 1))
    @assertEqual([1.0_rk, 3.0_rk], intersection_xy(:, 2))
    @assertEqual([.true., .true.], valid_intersection)
    angles(1) = intersection_angle_from_x_axis(circle_xy, intersection_xy(:, 1))
    angles(2) = intersection_angle_from_x_axis(circle_xy, intersection_xy(:, 2))
    @assertEqual([-0.5_rk * pi, 0.5_rk * pi], angles)

    ! Exactly 1 intersections on the circle
    line_xy(:, 1) = [0.0_rk, 0.0_rk]
    line_xy(:, 2) = [1.0_rk, 3.0_rk]
    call find_line_circle_intersections(line_xy, circle_xy, circle_radius, intersection_xy, valid_intersection)
    @assertEqual([1.0_rk, 3.0_rk], intersection_xy(:, 2))
    @assertEqual([-0.2_rk, -0.6_rk], intersection_xy(:, 1), 1e-6)
    @assertEqual([.false., .true.], valid_intersection)
    angles(1) = intersection_angle_from_x_axis(circle_xy, intersection_xy(:, 1))
    angles(2) = intersection_angle_from_x_axis(circle_xy, intersection_xy(:, 2))
    @assertEqual([-2.2142974356_rk, .5_rk * pi], angles, 1e-6)

    ! Only 1 intersection
    line_xy(:, 1) = [0.0_rk, 1.0_rk]
    line_xy(:, 2) = [4.0_rk, 1.0_rk]
    call find_line_circle_intersections(line_xy, circle_xy, circle_radius, intersection_xy, valid_intersection)
    @assertEqual([-1.0_rk, 1.0_rk], intersection_xy(:, 1))
    @assertEqual([3.0_rk, 1.0_rk], intersection_xy(:, 2))
    @assertEqual([.false., .true.], valid_intersection)
    angles(1) = intersection_angle_from_x_axis(circle_xy, intersection_xy(:, 1))
    angles(2) = intersection_angle_from_x_axis(circle_xy, intersection_xy(:, 2))
    @assertEqual([pi, 0.0_rk], angles)

    ! 2 intersections
    line_xy(:, 1) = [-2.0_rk, 1.0_rk]
    line_xy(:, 2) = [4.0_rk, 1.0_rk]
    call find_line_circle_intersections(line_xy, circle_xy, circle_radius, intersection_xy, valid_intersection)
    @assertEqual([-1.0_rk, 1.0_rk], intersection_xy(:, 1))
    @assertEqual([3.0_rk, 1.0_rk], intersection_xy(:, 2))
    @assertEqual([.true., .true.], valid_intersection)
    angles(1) = intersection_angle_from_x_axis(circle_xy, intersection_xy(:, 1))
    angles(2) = intersection_angle_from_x_axis(circle_xy, intersection_xy(:, 2))
    @assertEqual([pi, 0.0_rk], angles, 1e-6)

  end subroutine

  ! @test
  ! subroutine test_midpoint_leftright_cone_p_prime_below()
  !   !< Test the Mach cone, where the apex is a midpoint and P' is below it

  !   !  |          |
  !   !  |  cell 1  |
  !   !  |  (i,j)   |
  !   !  C1---M----C2
  !   !  |  (.) P'  |
  !   !  |  cell 2  |
  !   !  | (i,j-1)  |

  !   type(cone_t) :: mach_cone
  !   real(rk), dimension(2, 2, 2) :: midpoint_edge_vectors
  !   real(rk), dimension(4, 2) :: midpoint_state
  !   real(rk), dimension(4) :: reference_state = 1.0_rk
  !   integer(ik), dimension(2, 2) :: neighbor_cell_indices
  !   integer(ik) :: i, j
  !   real(rk), dimension(4, 2) :: theta

  !   i = 1
  !   j = 1
  !   ! <----M---->  (left and right vectors) these have (x_tail, y_tail) and (x_head, y_head)
  !   midpoint_edge_vectors = reshape([[3.0_rk, 4.0_rk], & ! tail, vector 1
  !                                    [0.0_rk, 4.0_rk], & ! head, vector 1
  !                                    [3.0_rk, 4.0_rk], & ! tail, vector 2
  !                                    [6.0_rk, 4.0_rk] & ! head, vector 2
  !                                    ], shape=[2, 2, 2])

  !   ! cell ordering is 1) top, 2) bottom
  !   neighbor_cell_indices = reshape([[i, j], &  ! cell above
  !                                    [i, j - 1] &  ! cell below
  !                                    ], shape=[2, 2])

  !   reference_state = [1.0_rk, 0.0_rk, 4.0_rk, 1.0_rk]
  !   midpoint_state = 1.0_rk

  !   mach_cone = new_cone(tau=1.0e-2_rk, &
  !                        edge_vectors=midpoint_edge_vectors, &
  !                        reconstructed_state=midpoint_state, &
  !                        reference_state=reference_state, &
  !                        cell_indices=neighbor_cell_indices)

  !   ! P' should be in the cell below the midpoint
  !   @assertEqual([3.0_rk, 3.96_rk], mach_cone%p_prime_xy)
  !   @assertEqual([.false., .true., .false., .false.], mach_cone%p_prime_in_cell)
  !   @assertEqual([i, j - 1], mach_cone%p_prime_ij)

  !   theta = 0.0_rk
  !   @assertEqual(theta, mach_cone%theta_ib)

  !   theta = 0.0_rk
  !   theta(2, :) = 2 * pi ! 1st and 2nd intersections should both be 2pi
  !   @assertEqual(theta, mach_cone%theta_ie)

  !   write(*, *) mach_cone

  ! end subroutine test_midpoint_leftright_cone_p_prime_below
end module test_cone
